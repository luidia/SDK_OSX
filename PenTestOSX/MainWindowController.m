//
//  MainWindowController.m
//  PenTestOSX
//
//  Created by LeeJaeYong on 2014. 3. 19..
//  Copyright (c) 2014ë…„ choi. All rights reserved.
//

#import "MainWindowController.h"
#import "DataImportWindowController.h"

#define AUDIO_DEV_MAX   255
#define AUDIO_USR_MAX   215

@interface MainWindowController ()<NSTextFieldDelegate, DrawViewWindowControllerDelegate, TimeTestWindowControllerDelegate, EquilCalibrationViewControllerDelegate, NSOpenSavePanelDelegate>
{
    BOOL m_penConntectedStatus;
    int temperatureCnt;
    
    IBOutlet NSTextView *debugTextView;
    
    IBOutlet NSTextField *downCntTextField;
    IBOutlet NSTextField *moveCntTextField;
    IBOutlet NSTextField *upCntTextField;
    IBOutlet NSTextField *totalCntTextField;
    IBOutlet NSTextField *byteTextField;
    IBOutlet NSTextField *kByteTextField;
    int downCnt;
    int moveCnt;
    int upCnt;
    
    IBOutlet NSTextField *pressTextField;
    IBOutlet NSTextField *modelCodeTextField;
    IBOutlet NSTextField *hwVerTextField;
    IBOutlet NSTextField *mcu1TextField;
    IBOutlet NSTextField *mcu2TextField;
    IBOutlet NSTextField *aliveSecTextFiled;
    IBOutlet NSTextField *tempTextField;
    
    IBOutlet NSTextField *statusTextField;
    IBOutlet NSTextField *rawXTextField;
    IBOutlet NSTextField *rawYTextField;
    IBOutlet NSTextField *convXTextField;
    IBOutlet NSTextField *convYTextField;
    
    IBOutlet NSTextField *directionTextField;
    IBOutlet NSTextField *flagTextField;
    IBOutlet NSSlider *volumeSlider;
    IBOutlet NSSegmentedControl *audioModeBtn;
    IBOutlet NSTextField *HIDTextField;
    
    IBOutlet NSTextField *batteryStationTextField;
    IBOutlet NSTextField *batteryPenTextField;
    
    int penErrorCnt;
    IBOutlet NSTextField *packetCntTextField;
    int packetCnt;
    float beforeRawX;
    float beforeRawY;
    int errCntX;
    int errCntY;
    IBOutlet NSTextField *errCntTextFieldX;
    IBOutlet NSTextField *errCntTextFieldY;
    IBOutlet NSButton *connectBtn;
    
    CGSize screenSize;
    
    long savePenSleepRemainingTime;
    int savePenAliveSec;
    BOOL isRecvEnvDataFirst;
    BOOL isFirstPenSleepOldDevice;
    NSAlert* penSleepView;
    
    NSThread* readThread;
    BOOL      readThreadPause;
    BOOL      readThreadStop;
    
    enum CalibrationSize curCalibrationSize;
    CGRect curCalibrationRect;
    NSColor* penColor;
    
    int equilPenLastConnection;
    int curConnectModelCode;
    
    BOOL bIsShowAllowMsg;
    
    DataImportWindowController* dataImportWindowController;
}
@property (retain) DataImportWindowController* dataImportWindowController;
@property (retain) NSAlert* penSleepView;

@property (readwrite) enum CalibrationSize curCalibrationSize;
@property (readwrite) CGRect curCalibrationRect;
@property (retain) NSColor* penColor;
@property (readwrite) int equilPenLastConnection;
@property (readwrite) int curConnectModelCode;

- (IBAction)clearLog:(id)sender;
- (IBAction)calibrationClicked:(id)sender;
- (IBAction)drawingClicked:(id)sender;
- (IBAction)stopPenClicked:(id)sender;
- (IBAction)reStartPenClicked:(id)sender;
- (IBAction)packetCountClearClicked:(id)sender;
- (IBAction)countClearClicked:(id)sender;
- (IBAction)timeTestClicked:(id)sender;

@end

@implementation MainWindowController
@synthesize drawViewWindowController;
@synthesize penController,penSleepCheckTimer;
@synthesize timeTestWindowController;
@synthesize calibController;
@synthesize penSleepView;
@synthesize curCalibrationSize, curCalibrationRect;
@synthesize penColor;
@synthesize equilPenLastConnection;
@synthesize curConnectModelCode;
@synthesize dataImportWindowController;

-(void) dealloc {
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"PNF_LOG_MSG" object:nil];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"PNF_PEN_READ_DATA" object:nil];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"PNF_MSG" object:nil];
    self.penController = nil;
    self.dataImportWindowController = nil;
    [super dealloc];
}

- (id)initWithWindow:(NSWindow *)window
{
    self = [super initWithWindow:window];
    if (self) {
        bIsShowAllowMsg = NO;
        self.calibController = nil;
        self.drawViewWindowController = nil;
        self.timeTestWindowController = nil;
        self.penSleepView = nil;
        penSleepCheckTimer = nil;
        self.dataImportWindowController = nil;
        self.curCalibrationRect = CGRectZero;
        self.curCalibrationSize = A4;
        self.penColor = [NSColor colorWithRed:0 green:0 blue:0 alpha:1];
        
        if (![[NSUserDefaults standardUserDefaults] objectForKey:@"kEquilPenLastConnection"]) {
            [[NSUserDefaults standardUserDefaults] setInteger:0 forKey:@"kEquilPenLastConnection"];
            [[NSUserDefaults standardUserDefaults] synchronize];
        }
        self.equilPenLastConnection = (int)[[[NSUserDefaults standardUserDefaults] objectForKey:@"kEquilPenLastConnection"] integerValue];
        self.curConnectModelCode = -1;
    }
    return self;
}
-(void) SmartmarkerEnable:(BOOL)enable {
    [directionTextField setEnabled:enable];
    [flagTextField setEnabled:enable];
    [propertiesTextField setEnabled:enable];
    [volumeSlider setEnabled:enable];
    [audioModeBtn setEnabled:enable];
}
-(void) addDebugText:(NSString*)text {
    NSString* t = [NSString stringWithFormat:@"%@\n%@", debugTextView.string, text];
    [debugTextView setString:t];
    [debugTextView scrollRangeToVisible:NSMakeRange([debugTextView.string length], 0)];
}

- (BOOL)windowShouldClose:(NSWindow *)sender {
    [self closeSelf];
    return NO;
}
-(void) closeSelf {
    if (self.drawViewWindowController)
        self.drawViewWindowController = nil;
    
    [NSApp stop:nil];
}
- (void)windowDidLoad
{
    [super windowDidLoad];
    
    isFirstPenSleepOldDevice = NO;
    isRecvEnvDataFirst = YES;
    
    screenSize = CGSizeMake(600, 700);
    
    self.drawViewWindowController = nil;
    
    packetCnt = 0;
    errCntX = 0;
    errCntY = 0;
    beforeRawX = -1;
    beforeRawY = -1;
    [self updatePacketCnt];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(FreeLogMsg:) name:@"PNF_LOG_MSG" object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(PenHandlerWithMsg:) name:@"PNF_PEN_READ_DATA" object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(PenCallBackFunc:) name:@"PNF_MSG" object:nil];
    
    [self SmartmarkerEnable:NO];
    
    [self setPNFPenLib];
}
-(void) setPNFPenLib {
    NSLog(@"setPNFPenLib");
    penController = [[PNFPenController alloc] init];
    [penController setRetObj:self];
    [penController setRetObjForEnv:self];
    [penController setNonSandbox];
}
- (IBAction)connectBtnClicked:(id)sender {
    if (penController.bConnected) {
        if (penController.bConnectedHID)
            return;
        [penController disConnectPen];
    }
    else {
        NSArray* arr = [penController savePenInfoCount];
        if (arr.count == 0) {
            self.curConnectModelCode = -1;
            int ret = [penController startPen:self.curConnectModelCode];
            NSLog(@"Start Pen ret = %d",ret);
        }
        else if (arr.count == 1) {
            self.curConnectModelCode = [[arr objectAtIndex:0] intValue];
            int ret = [penController startPen:self.curConnectModelCode];
            NSLog(@"Start Pen ret = %d",ret);
        }
        else {
            BOOL find = NO;
            for (int i=0; i<arr.count; i++) {
                if (self.equilPenLastConnection == [[arr objectAtIndex:i] intValue]) {
                    find = YES;
                    break;
                }
            }
            if (find) {
                self.curConnectModelCode = self.equilPenLastConnection;
                int ret = [penController startPen:self.curConnectModelCode];
                NSLog(@"Start Pen ret = %d",ret);
            }
            else {
                self.curConnectModelCode = [[arr objectAtIndex:0] intValue];
                int ret = [penController startPen:self.curConnectModelCode];
                NSLog(@"Start Pen ret = %d",ret);
            }
        }
    }
}
-(void) showPenStatus:(BOOL)connect {
    if(connect)
        [connectBtn setTitle:@"Disconnect"];
    else
        [connectBtn setTitle:@"Connect"];
}

-(void) BTErrorProcessRet:(NSAlert *)alert returnCode:(int)returnCode contextInfo:(void *)contextInfo {
    if (penController.bConnectedHID)
        return;
    NSLog(@"retcode = %d",returnCode);
    if (returnCode == NSAlertFirstButtonReturn) {
        NSLog(@"first button try again");
        [penController startPen:self.curConnectModelCode];
    }
    else if(returnCode == NSAlertSecondButtonReturn)
    {
        NSLog(@"second button init");
        [penController InitBTConnection:self.curConnectModelCode];
        self.curConnectModelCode = -1;
        [penController startPen:self.curConnectModelCode];
    }
    else {
        self.curConnectModelCode = -1;
    }
}

-(void) BTErrorProcess {
    NSAlert* alert = [[[NSAlert alloc] init] autorelease];
    [alert addButtonWithTitle:@"Retry"];
    [alert addButtonWithTitle:@"Pairing"];
    [alert addButtonWithTitle:@"Cancel"];
    [alert setMessageText:@"Can not connect pen."];
    [alert setAlertStyle:NSInformationalAlertStyle];
    [alert beginSheetModalForWindow:self.window
                      modalDelegate:self
                     didEndSelector:@selector(BTErrorProcessRet:returnCode:contextInfo:)
                        contextInfo:NULL];
    
}
-(void) FreeLogMsg:(NSNotification *) note
{
	NSString * szS = (NSString *) [note object];
    NSLog(@"=== szS [%@]", szS);
    if ([szS compare:@"FAIL_LISTENING"] == 0 ) {
        NSAlert* alert = [[[NSAlert alloc] init] autorelease];
        [alert addButtonWithTitle:@"Ok"];
        [alert setMessageText:@"abnormal connect. please reconnect device"];
        [alert setAlertStyle:NSInformationalAlertStyle];
        [alert beginSheetModalForWindow:self.window
                          modalDelegate:nil
                         didEndSelector:nil
                            contextInfo:NULL];
        return;
    }
    else if ([szS isEqualToString:@"CONNECTED"]) {
        [self addDebugText:szS];
        penErrorCnt = 0;
        isFirstPenSleepOldDevice = NO;
    }
    else if ([szS isEqualToString:@"INVALID_PROTOCOL"]) {
        [self addDebugText:@"INVALID_PROTOCOL"];
        [NSTimer scheduledTimerWithTimeInterval:1
                                         target:self
                                       selector:@selector(BTErrorProcess)
                                       userInfo:nil
                                        repeats:NO];
        return;
    }
    else if ([szS isEqualToString:@"FAIL_CONNECTING"]) {
        [self addDebugText:@"FAIL_CONNECTING"];
        [NSTimer scheduledTimerWithTimeInterval:1
                                         target:self
                                       selector:@selector(BTErrorProcess)
                                       userInfo:nil
                                        repeats:NO];
        return;
    }
    else if ([szS isEqualToString:@"SESSION_CLOSED"]) {
        [self SmartmarkerEnable:NO];
        [HIDTextField setStringValue:@""];
        [self addDebugText:szS];
        [self penIdleTimerStop];
        self.curConnectModelCode = -1;
        isFirstPenSleepOldDevice = NO;
        [self closePenSleepView];
    }
    else if ([szS isEqualToString:@"PEN_RMD_ERROR"]) {
        [self addDebugText:@"PEN_RMD_ERROR"];
        if (penController && (penController.PenStatus == PEN_DOWN || penController.PenStatus == PEN_MOVE)) {
            penErrorCnt++;
            NSLog(@"penErrorCnt = %d", penErrorCnt);
        }
        return;
    }
    else if ([szS isEqualToString:@"FIRST_DATA_RECV"]) {
        [self addDebugText:szS];
        
        self.equilPenLastConnection = penController.modelCode;
        [[NSUserDefaults standardUserDefaults] setInteger:self.equilPenLastConnection forKey:@"kEquilPenLastConnection"];
        [[NSUserDefaults standardUserDefaults] synchronize];
        
        self.curConnectModelCode = penController.modelCode;
        
        if (penController.modelCode == EquilSmartMarker) {
            [self SmartmarkerEnable:YES];
            if (self.penController.AudioMode)
                [audioModeBtn setSelectedSegment:1];
            else
                [audioModeBtn setSelectedSegment:0];
            
            [volumeSlider setMinValue:0];
            [volumeSlider setMaxValue:AUDIO_USR_MAX];
            int value = AUDIO_DEV_MAX-(int)self.penController.Volume;
            if (value > AUDIO_USR_MAX) {
                value = AUDIO_USR_MAX;
                [self.penController changeVolume:AUDIO_DEV_MAX-AUDIO_USR_MAX];
            }
            [volumeSlider setDoubleValue:value];
            
            if (penController.bConnectedHID) {
                [HIDTextField setStringValue:@"USB"];
            }
            else {
                [HIDTextField setStringValue:@"Bluetooth"];
            }
        }
    }
    else if ([szS isEqualToString:@"CLICK"] ||
             [szS isEqualToString:@"DOUBLE_CLICK"] ||
             [szS isEqualToString:@"Gesture Circle Clockwise"] ||
             [szS isEqualToString:@"Gesture Circle CounterClockwise"]) {
        [self addDebugText:szS];
        [self penIdleTimerStop];
        [self closePenSleepView];
        return;
    }
    else if ([szS isEqualToString:@"SHOW_ALLOW_ACCESS"]) {
        if (bIsShowAllowMsg)
            return;
        bIsShowAllowMsg = YES;
        NSString* msg = @"Equil SmartMarker needs to access this path to continue. Click Allow to continue.";
        NSOpenPanel *openPanel = [NSOpenPanel openPanel];
        openPanel.delegate = self;
        [openPanel setMessage:msg];
        [openPanel setCanChooseFiles:NO];
        [openPanel setCanCreateDirectories:NO];
        [openPanel setCanChooseDirectories:YES];
        [openPanel setAllowsMultipleSelection:NO];
        NSString* path = [[penController USBManager_BookmarkPath] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
        [openPanel setDirectoryURL:[NSURL URLWithString:path]];
        [openPanel setTitle:@"Allow Access"];
        [openPanel setPrompt:@"Allow"];
        [openPanel beginSheetModalForWindow:[NSApp mainWindow]
                          completionHandler:^(NSInteger result){
                              if (result == NSOKButton) {
                                  NSURL* tBookmarkURL = [openPanel URL];
                                  NSLog(@"bookmarkURL = %@", tBookmarkURL);
                                  NSError *error = nil;
                                  NSData* tBookmarkData = [[openPanel URL] bookmarkDataWithOptions:NSURLBookmarkCreationWithSecurityScope
                                                                    includingResourceValuesForKeys:nil
                                                                                     relativeToURL:nil // Make it app-scoped
                                                                                             error:&error];
                                  [penController USBManager_setBookmarkData:tBookmarkData];
                              }
                              bIsShowAllowMsg = NO;
                          }];
    }
    else if ([szS isEqualToString:@"NOT_FOUND_HID_DEVICE"]) {
        NSArray* arr = [penController savePenInfoCount];
        if (arr.count == 0) {
            self.curConnectModelCode = -1;
            int ret = [penController startPen:self.curConnectModelCode];
            NSLog(@"Start Pen ret = %d",ret);
        }
        else if (arr.count == 1) {
            self.curConnectModelCode = [[arr objectAtIndex:0] intValue];
            int ret = [penController startPen:self.curConnectModelCode];
            NSLog(@"Start Pen ret = %d",ret);
        }
        else {
            BOOL find = NO;
            for (int i=0; i<arr.count; i++) {
                if (self.equilPenLastConnection == [[arr objectAtIndex:i] intValue]) {
                    find = YES;
                    break;
                }
            }
            if (find) {
                self.curConnectModelCode = self.equilPenLastConnection;
                int ret = [penController startPen:self.curConnectModelCode];
                NSLog(@"Start Pen ret = %d",ret);
            }
            else {
                self.curConnectModelCode = [[arr objectAtIndex:0] intValue];
                int ret = [penController startPen:self.curConnectModelCode];
                NSLog(@"Start Pen ret = %d",ret);
            }
        }
    }
    else
        return;

    [self checkPenConnect];
    packetCnt++;
    [self updatePacketCnt];
    [mcu1TextField setStringValue:[NSString stringWithFormat:@"%d", penController.MCU1Version]];
    [mcu2TextField setStringValue:[NSString stringWithFormat:@"%d", penController.MCU2Version]];
    [hwVerTextField setStringValue:[NSString stringWithFormat:@"%d", penController.HWVersion]];
}
-(void) updateErrCntX {
    [errCntTextFieldX setStringValue:[NSString stringWithFormat:@"%d", errCntX]];
}
-(void) updateErrCntY {
    [errCntTextFieldY setStringValue:[NSString stringWithFormat:@"%d", errCntY]];
}

-(void) updatePacketCnt {
    [packetCntTextField setStringValue:[NSString stringWithFormat:@"%d", packetCnt]];
}

-(void) updateDrawCnt {
    [downCntTextField setStringValue:[NSString stringWithFormat:@"%d", downCnt]];
    [moveCntTextField setStringValue:[NSString stringWithFormat:@"%d", moveCnt]];
    [upCntTextField setStringValue:[NSString stringWithFormat:@"%d", upCnt]];
    [totalCntTextField setStringValue:[NSString stringWithFormat:@"%d", downCnt+moveCnt+upCnt]];
    float byte = 0;
    if (downCnt+moveCnt+upCnt == 0)
        [byteTextField setStringValue:[NSString stringWithFormat:@"%d", 0]];
    else {
        [byteTextField setStringValue:[NSString stringWithFormat:@"%d", ((downCnt+moveCnt+upCnt)*6)+((downCnt+moveCnt+upCnt)/12)+1]];
        byte = ((downCnt+moveCnt+upCnt)*6)+((downCnt+moveCnt+upCnt)/12)+1;
    }
    [kByteTextField setStringValue:[NSString stringWithFormat:@"%.3f", byte/1024.f]];
}

-(void) lazyCheckCalibration {
    if (![penController bExistCalibrationInfo]) {
        [self addDebugText:@"calibration data not exist"];
    }
    else {
        [self addDebugText:@"calibration data exist"];
    }
    
    if (penController.modelCode == Equil) {
        [self addDebugText:@"Equil"];
    }
    else if (penController.modelCode == EquilPro) {
        [self addDebugText:@"Equil 2"];
    }
    else if (penController.modelCode == EquilSmartMarker) {
        [self addDebugText:@"Equil Smartmarker"];
    }
    [self initCalibration];
    if (self.penController.modelCode == EquilSmartMarker) {
        [self ReadThreadStart];
    }
    else{
        [self ReadThreadOff];
    }
    [modelCodeTextField setStringValue:[NSString stringWithFormat:@"%d", penController.modelCode]];
}

-(void) checkPenConnect {
    if (m_penConntectedStatus == penController.bConnected) {
        return;
    }
    if (penController.bConnected) {
        m_penConntectedStatus = YES;
        [NSTimer scheduledTimerWithTimeInterval:3.0f
                                         target:self
                                       selector:@selector(lazyCheckCalibration)
                                       userInfo:nil
                                        repeats:NO];
    }
    else {
        m_penConntectedStatus = NO;
    }
    
    [self showPenStatus:penController.bConnected];
}

-(void) initCalibration {
    if (penController.modelCode == Equil || penController.modelCode == EquilPro) {
        CGPoint calResultPoint[4];
        NSString *locale = [[NSLocale currentLocale] localeIdentifier];
        if ([locale isEqualToString:@"en_US"] || [locale isEqualToString:@"en_CA"]) {
            // Letter
            LETTER()
            self.curCalibrationSize = Letter;
        }
        else {
            // A4
            A4()
            self.curCalibrationSize = A4;
        }
        float w = calResultPoint[2].x-calResultPoint[0].x;
        float h = calResultPoint[1].y-calResultPoint[0].y;
        self.curCalibrationRect = CGRectMake(calResultPoint[0].x, calResultPoint[0].y, w, h);
        [self.penController setCalibrationData:CGRectMake(0, 0, screenSize.width, screenSize.height)
                                   GuideMargin:0
                                    CalibPoint:calResultPoint];
    }
    else if (self.penController.modelCode == EquilSmartMarker) {
        self.curCalibrationSize = FT8X5;
        CGPoint calResultPoint[4];
        FT_8X5()
        float w = calResultPoint[2].x-calResultPoint[0].x;
        float h = calResultPoint[1].y-calResultPoint[0].y;
        self.curCalibrationRect = CGRectMake(calResultPoint[0].x, calResultPoint[0].y, w, h);
        [self.penController setCalibrationData:CGRectMake(0, 0, screenSize.width, screenSize.height)
                                   GuideMargin:0
                                    CalibPoint:calResultPoint];
    }
}

#pragma mark - PenController
-(void) penIdleTimerStop {
    if(penSleepCheckTimer != nil){
        [penSleepCheckTimer invalidate];
        [penSleepCheckTimer release];
        penSleepCheckTimer = nil;
    }
}
-(void) closePenSleepView {
    if (self.penSleepView) {
        NSArray *buttonArray = [self.penSleepView buttons];
        NSButton *myBtn = [buttonArray objectAtIndex:0];
        [myBtn performClick:self.penSleepView];
    }
}
-(void) showPenSleepView {
    self.penSleepView = [[[NSAlert alloc] init] autorelease];
    [self.penSleepView addButtonWithTitle:@"Ok"];
    [self.penSleepView setMessageText:@"Press Pen power button once to use as the pen is on sleep mode."];
    [self.penSleepView setAlertStyle:NSInformationalAlertStyle];
    [self.penSleepView beginSheetModalForWindow:self.window
                      modalDelegate:nil
                     didEndSelector:nil
                        contextInfo:NULL];
}
-(void) PenHandlerEnv:(NSArray*)info {
    if (penController.modelCode == EquilSmartMarker) {
        
    }
    else {
        [aliveSecTextFiled setStringValue:[NSString stringWithFormat:@"%d", penController.penAliveSec]];
    }
    
    NSLog(@"m_PenController.MCU1Version = %d", penController.MCU1Version);
    NSLog(@"m_PenController.MCU2Version = %d", penController.MCU2Version);
    NSLog(@"m_PenController.HWVersion = %d", penController.HWVersion);
    if (penController.MCU1Version >= 2 && penController.MCU2Version >= 2 && penController.HWVersion >= 2) {
        NSLog(@"m_PenController.penAliveSec = %d", penController.penAliveSec);
        if (penController.penAliveSec > 0) {
            [self closePenSleepView];
        }
    }
    if (isRecvEnvDataFirst) {
        isRecvEnvDataFirst = NO;
        [self penIdleTimerStop];
        penSleepCheckTimer = [[NSTimer scheduledTimerWithTimeInterval:5
                                                               target:self
                                                             selector:@selector(onTimerForPenAlive:)
                                                             userInfo:nil
                                                              repeats:YES] retain];
        savePenSleepRemainingTime = [[NSDate date] timeIntervalSince1970] + 600;
        savePenAliveSec = 600;
    }
}
- (void) onTimerForPenAlive:(NSTimer *)timer {
    long curTime = [[NSDate date] timeIntervalSince1970];
    BOOL check = NO;
    if (self.penController.modelCode == Equil) {
        if (self.penController.MCU1Version >= 2 && self.penController.MCU2Version >= 2 && self.penController.HWVersion >= 2) {
            check = YES;
        }
    }
    else if (self.penController.modelCode == EquilPro) {
        if (self.penController.MCU1Version >= 1 && self.penController.MCU2Version >= 1 && self.penController.HWVersion >= 1) {
            check = YES;
        }
    }
    else if (self.penController.modelCode == EquilSmartMarker) {
        return;
    }
    
    if (check) {
        if (penController.penAliveSec == 0) {
            [self showPenSleepView];
            [self penIdleTimerStop];
            return;
        }
        if (penController.penAliveSec != 0 && savePenAliveSec != penController.penAliveSec) {
            savePenAliveSec = penController.penAliveSec;
            savePenSleepRemainingTime = curTime + penController.penAliveSec;
        }
    }
    else {
        if (!isFirstPenSleepOldDevice) {
            isFirstPenSleepOldDevice = YES;
            savePenSleepRemainingTime = curTime - 10;
        }
    }
    NSLog(@"***********************************");
    NSLog(@"curTime = %ld", curTime);
    NSLog(@"savePenSleepRemainingTime = %ld", savePenSleepRemainingTime);
    NSLog(@"savePenSleepRemainingTime - curTime = %ld", savePenSleepRemainingTime - curTime);
    NSLog(@"savePenAliveSec = %d", savePenAliveSec);
    if (savePenSleepRemainingTime < curTime) {
        [self showPenSleepView];
        [self penIdleTimerStop];
    }
}
-(void) PenHandler:(id)sender {
    // deprecated
}
-(void) ReadThreadStart {
    [self addDebugText:@"ReadThreadStart"];
    if (readThread == nil) {
        readThread = [[NSThread alloc] initWithTarget:self
                                             selector:@selector(runReadThread) object:self];
        readThreadStop=NO;
        readThreadPause=NO;
        [readThread start];
        
    }
    if (penController) {
        [penController StartReadQ];
    }
}
-(void) runReadThread {
    @autoreleasepool {
        while (1) {
            if (readThreadStop) {
                break;
            }
            NSDictionary* dic = [self.penController ReadQ];
            if(dic) {
                [self performSelectorOnMainThread:@selector(PenHandlerWithDictionary:) withObject:dic waitUntilDone:YES];
                [self.penController RemoveQ];
            }
            else {
                [NSThread sleepForTimeInterval:0.02];
            }
        } // while (1) {
    }
}
-(void) ReadThreadOff {
    [self addDebugText:@"ReadThreadOff"];
    readThreadStop = YES;
    [NSThread sleepForTimeInterval:0.2];
    if (readThread) {
        [readThread cancel];
        [readThread release];
        readThread = nil;
    }
    if (self.penController) {
        [self.penController EndReadQ];
    }
}
-(void) PenCallBackFunc:(NSNotification *)call {
    NSString * szS = (NSString *) [call object];
    if([szS isEqualToString:@"BATTERY_INFO"]) {
        if (self.penController.modelCode == EquilSmartMarker || self.penController.modelCode == EquilPro) {
            [batteryStationTextField setStringValue:[NSString stringWithFormat:@"%d%%", self.penController.battery_station]];
        }
        else
            [batteryStationTextField setStringValue:@"No Data"];
        
        if (self.penController.battery_station == -1)
            [batteryStationTextField setStringValue:@"No Data"];
        
        if (self.penController.modelCode == EquilSmartMarker) {
            [batteryPenTextField setStringValue:[NSString stringWithFormat:@"%@", self.penController.battery_pen?@"LOW":@"HIGH"]];
        }
        else if (self.penController.modelCode == EquilPro) {
            [batteryPenTextField setStringValue:[NSString stringWithFormat:@"%d%%", self.penController.battery_pen]];
        }
        else
            [batteryPenTextField setStringValue:@"No Data"];
    }
    else if([szS isEqualToString:@"NEW_PAGE"] || [szS isEqualToString:@"DUPLICATE_PAGE"]) {
        [self addDebugText:szS];
    }
    else if ([szS isEqualToString:@"CHANGE_DEVECE_POSITION"] || [szS isEqualToString:@"CHANGE_DEVECE_POSITION_FIRST"]) {
        [directionTextField setStringValue:@"Left"];
        if (self.penController.StationPosition == DIRECTION_LEFT)
            [directionTextField setStringValue:@"Left"];
        else if (self.penController.StationPosition == DIRECTION_RIGHT)
            [directionTextField setStringValue:@"Left"];
        else if (self.penController.StationPosition == DIRECTION_TOP)
            [directionTextField setStringValue:@"Top"];
        else if (self.penController.StationPosition == DIRECTION_BOTTOM)
            [directionTextField setStringValue:@"Bottom"];
    }
}
-(void) PenHandlerWithMsg:(NSNotification*) note {
    NSDictionary* dic = [note object];
    if ([self.penController getRetObj] != self)
        return;
    [self PenHandlerWithDictionary:dic];
}
-(void) PenHandlerWithDictionary:(NSDictionary*) dic {
    int PenStatus  = [[dic objectForKey:@"PenStatus"] intValue];
    CGPoint ptRaw = [[dic objectForKey:@"ptRaw"] pointValue];
    CGPoint ptConv = [[dic objectForKey:@"ptConv"] pointValue];
    int Temperature = [[dic objectForKey:@"Temperature"] intValue];
    int modelCode = [[dic objectForKey:@"modelCode"] intValue];
    int SMPenFlag = [[dic objectForKey:@"SMPenFlag"] intValue];
    int SMPenState = [[dic objectForKey:@"SMPenState"] intValue];
    int press = [[dic objectForKey:@"pressure"] intValue];
    [self PenHandlerWithArgs:ptRaw
                      ptConv:ptConv
                   PenStatus:PenStatus
                 Temperature:Temperature
                   ModelCode:modelCode
                   SMPenFlag:SMPenFlag
                  SMPenState:SMPenState
                    Pressure:press];
}
-(void) PenHandlerWithArgs:(CGPoint) Arg_ptRaw ptConv:(CGPoint) Arg_ptConv PenStatus:(int) Arg_PenStatus
               Temperature:(int) Arg_Temperature ModelCode:(int) Arg_modelCode
                SMPenFlag :(int) Arg_SMPenFlag SMPenState:(int) Arg_SMPenState
                  Pressure:(int) Arg_pressure {
    isRecvEnvDataFirst = YES;
    [self penIdleTimerStop];
    [self closePenSleepView];
    
    if (penController == nil) {
        [self addDebugText:@"PenController is not set"];
        return;
    }
    [statusTextField setStringValue:[NSString stringWithFormat:@"%d", Arg_PenStatus]];
    [tempTextField setStringValue:[NSString stringWithFormat:@"%d", Arg_Temperature]];
    [rawXTextField setStringValue:[NSString stringWithFormat:@"%f", Arg_ptRaw.x]];
    [rawYTextField setStringValue:[NSString stringWithFormat:@"%f", Arg_ptRaw.y]];
    [convXTextField setStringValue:[NSString stringWithFormat:@"%f", Arg_ptConv.x]];
    [convYTextField setStringValue:[NSString stringWithFormat:@"%f", Arg_ptConv.y]];
    [modelCodeTextField setStringValue:[NSString stringWithFormat:@"%d", Arg_modelCode]];
    
    if (Arg_modelCode == EquilSmartMarker) {
        if (Arg_SMPenFlag & 0x01) {
            [flagTextField setStringValue:@"Right"];
        }
        else {
            [flagTextField setStringValue:@"Left"];
        }
    }
   
    if (Arg_modelCode == Equil || Arg_modelCode == EquilPro) {
        [pressTextField setStringValue:[NSString stringWithFormat:@"%d", Arg_pressure]];
    }
    else {
        [pressTextField setStringValue:@""];
    }
    if (Arg_modelCode == EquilSmartMarker) {
        [self setPenPropertiesForSM:Arg_SMPenState];
    }
    switch (Arg_PenStatus) {
        case PEN_DOWN:
            downCnt++;
            break;
        case PEN_MOVE:
            moveCnt++;
            break;
        case PEN_UP:
            upCnt++;
            break;
        case PEN_HOVER:
            break;
        default:
            break;
    }
    [self updateDrawCnt];
    if (beforeRawX == -1) {
        beforeRawX = Arg_ptRaw.x;
    }
    else {
        if (Arg_ptRaw.x-beforeRawX>1.0f) {
            errCntX++;
            [self updateErrCntX];
        }
    }
    if (beforeRawY == -1) {
        beforeRawY = Arg_ptRaw.y;
    }
    else {
        if (Arg_ptRaw.y-beforeRawY>1.0f) {
            errCntY++;
            [self updateErrCntY];
        }
    }

    if (self.drawViewWindowController) {
        CGPoint p = CGPointMake(Arg_ptConv.x, self.drawViewWindowController.drawView.frame.size.height-Arg_ptConv.y);
        BOOL erase = NO;
        BOOL big = NO;
        float eraseSize = 0.;
        if (Arg_modelCode == EquilSmartMarker &&
            ([[propertiesTextField stringValue] isEqualToString:@"Erase Cap"] || [[propertiesTextField stringValue] isEqualToString:@"Erase Big"])) {
            erase = YES;
            if ([[propertiesTextField stringValue] isEqualToString:@"Erase Big"])
                big = YES;
            eraseSize = [penController calcSmartMarkerEraseThick:big];
        }
        [self.drawViewWindowController SetDrawInfo:Arg_PenStatus pressure:Arg_pressure pt:p color:self.penColor erase:erase eraseSize:eraseSize];
    }
}
-(void) setPenPropertiesForSM:(int)Arg_SMPenState {
    NSString* smProperties = @"";
    switch (Arg_SMPenState) {
        case 0x51: // red marker
            smProperties = @"Red";
            self.penColor = [NSColor colorWithRed:1.0 green:0 blue:0 alpha:1];
            break;
        case 0x52: // green marker
            smProperties = @"Green";
            self.penColor = [NSColor colorWithRed:60.0/255.0 green:184.0/255.0 blue:120.0/255.0 alpha:1];
            break;
        case 0x53:
            smProperties = @"Yellow";
            self.penColor = [NSColor colorWithRed:1.0 green:1.0 blue:0 alpha:1];
            break;
        case 0x54:
            smProperties = @"Blue";
            self.penColor = [NSColor colorWithRed:0 green:0 blue:1.0 alpha:1];
            break;
        case 0x56:
            smProperties = @"Violet";
            self.penColor = [NSColor colorWithRed:128.0/255.0 green:0 blue:128.0/255.0 alpha:1];
            break;
        case 0x58:
            smProperties = @"Black";
            self.penColor = [NSColor colorWithRed:0 green:0 blue:0 alpha:1];
            break;
        case 0x59:  // eraser cap
            smProperties = @"Erase Cap";
            self.penColor = [NSColor colorWithRed:255./255. green:255./255. blue:255./255. alpha:1];
            break;
        case 0x50:
        case 0x5C:  // big eraser
            smProperties = @"Erase Big";
            self.penColor = [NSColor colorWithRed:255./255. green:255./255. blue:255./255. alpha:1];
            break;
        default:
            break;
    }
    [propertiesTextField setStringValue:smProperties];
}
- (IBAction)clearLog:(id)sender{
    [debugTextView setString:@""];
}

- (IBAction)stopPenClicked:(id)sender{
    if (penController) {
        [penController stopPen];
    }
}
- (IBAction)reStartPenClicked:(id)sender{
    if (penController) {
        [penController restartPen];
    }
}
- (IBAction)packetCountClearClicked:(id)sender {
    packetCnt = 0;
    errCntX = 0;
    errCntY = 0;
    beforeRawX = -1;
    beforeRawY = -1;
    [self updateErrCntX];
    [self updateErrCntY];
    [self updatePacketCnt];
}
- (IBAction)countClearClicked:(id)sender{
    downCnt = 0;
    moveCnt= 0;
    upCnt = 0;
    [self updateDrawCnt];
}
- (IBAction)volumechanged:(id)sender {
    int value = AUDIO_DEV_MAX-(int)[volumeSlider doubleValue];
    [penController changeVolume:value];
}
- (IBAction)audioModeClicked:(id)sender {
    [penController changeAudioMode:[audioModeBtn selectedSegment] == 0 ? NO : YES];
}

#pragma mark - CalibrationViewWindowController
- (IBAction)calibrationClicked:(id)sender {
    self.dataImportWindowController = nil;
    self.drawViewWindowController = nil;
    self.timeTestWindowController = nil;
    self.calibController = nil;
    
    self.calibController = [[[CalibWindowController alloc] initWithWindowNibName:@"CalibWindowController"] autorelease];
    self.calibController.equilCalibViewController.delegate = self;
    self.calibController.equilCalibViewController.curScreenSize = screenSize;
    [self.calibController.equilCalibViewController SetPenController:penController];
    [[NSApplication sharedApplication] beginSheet:calibController.window
                                   modalForWindow:self.window
                                    modalDelegate:nil
                                   didEndSelector:nil
                                      contextInfo:nil];
}
-(void) closeCalibViewController_FromEquilCalibrationViewController {
    [penController setRetObj:self];
    [penController setRetObjForEnv:self];
    [NSTimer scheduledTimerWithTimeInterval:0.1
                                     target:self
                                   selector:@selector(closeCalibViewControllerImpl)
                                   userInfo:nil
                                    repeats:NO];
}
-(void) closeCalibViewController_FromEquilCalibrationViewController:(CGRect)rect caliRect:(CGRect)caliRect {
    [penController setRetObj:self];
    [penController setRetObjForEnv:self];
    [NSTimer scheduledTimerWithTimeInterval:0.1
                                     target:self
                                   selector:@selector(closeCalibViewControllerImpl)
                                   userInfo:nil
                                    repeats:NO];
    
    [NSTimer scheduledTimerWithTimeInterval:0.1
                                     target:self
                                   selector:@selector(closeCalibViewControllerImpl2:)
                                   userInfo:[NSArray arrayWithObjects:[NSValue valueWithRect:rect], [NSValue valueWithRect:caliRect], nil]
                                    repeats:NO];
}
-(void) closeCalibViewControllerImpl {
    [NSApp endSheet:self.calibController.window];
    [self.calibController.window orderOut:nil];
    self.calibController = nil;
}
-(void) closeCalibViewControllerImpl2:(NSTimer*)t {
    NSArray* info = (NSArray*)t.userInfo;
    CGRect rect = [[info objectAtIndex:0] rectValue];
    CGRect caliRect = [[info objectAtIndex:1] rectValue];
    if (!CGRectEqualToRect(rect, CGRectZero)) {
        self.curCalibrationSize = Custom;
        self.curCalibrationRect = caliRect;
    }
}
#pragma mark CalibrationViewWindowController End

#pragma mark - DrawViewWindowController
-(void) closeDrawViewWindowController {
    [NSTimer scheduledTimerWithTimeInterval:0.1
                                     target:self
                                   selector:@selector(closeDrawViewWindowControllerImpl)
                                   userInfo:nil
                                    repeats:NO];
}
-(void) closeDrawViewWindowControllerImpl {
    self.drawViewWindowController = nil;
    self.dataImportWindowController = nil;
}
- (IBAction)drawingClicked:(id)sender {
    self.dataImportWindowController = nil;
    self.drawViewWindowController = nil;
    self.timeTestWindowController = nil;
    self.calibController = nil;

    self.drawViewWindowController = [[[DrawViewWindowController alloc] initWithWindowNibName:@"DrawViewWindowController"] autorelease];
    self.drawViewWindowController.delegate = self;
    self.drawViewWindowController.penController = self.penController;
    self.drawViewWindowController.calibrationRect = self.curCalibrationRect;
    self.drawViewWindowController.calibrationSize = self.curCalibrationSize;
    [self.drawViewWindowController showWindow:self];
    [penController changeScreenSize:self.drawViewWindowController.drawView.bounds];
    screenSize = self.drawViewWindowController.drawView.bounds.size;
}

- (IBAction)thresholdClicked:(id)sender {
    self.dataImportWindowController = nil;
}
#pragma mark DrawViewWindowController End

#pragma mark - TimeTestWindowController
-(void) closeTimeTestWindowController {
    [NSTimer scheduledTimerWithTimeInterval:0.1
                                     target:self
                                   selector:@selector(closeTimeTestWindowControllerImpl)
                                   userInfo:nil
                                    repeats:NO];
}
-(void) closeTimeTestWindowControllerImpl {
    self.drawViewWindowController = nil;
    self.timeTestWindowController = nil;
    self.calibController = nil;

    [penController setRetObj:self];
    [penController setRetObjForEnv:self];
}
- (IBAction)timeTestClicked:(id)sender{
    self.timeTestWindowController = nil;
    self.timeTestWindowController = [[[TimeTestWindowController alloc] initWithWindowNibName:@"TimeTestWindowController"] autorelease];
    self.timeTestWindowController.delegate = self;
    [penController setRetObj:self.timeTestWindowController];
    [penController setRetObjForEnv:self.timeTestWindowController];
    [self.timeTestWindowController showWindow:self];
}
#pragma mark TimeTestWindowController - End
#pragma mark - Data Import
- (IBAction)diClicked:(id)sender {
    self.dataImportWindowController = nil;
    self.drawViewWindowController = nil;
    self.timeTestWindowController = nil;
    self.calibController = nil;
    
    self.dataImportWindowController = [[[DataImportWindowController alloc] initWithWindowNibName:@"DataImportWindowController"] autorelease];
    [self.dataImportWindowController SetPenController:penController];
    //    self.dataImportWindowController.delegate = self;
    [self.dataImportWindowController showWindow:self];
}
#pragma mark - Data Import End

@end
